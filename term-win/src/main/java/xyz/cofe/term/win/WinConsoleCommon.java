package xyz.cofe.term.win;

import com.sun.jna.WString;
import com.sun.jna.platform.win32.WinDef;
import com.sun.jna.platform.win32.WinNT;

import static xyz.cofe.term.win.WinConsoleError.throwError;
import static xyz.cofe.term.win.impl.RawAPIHolder.rawAPI;

public class WinConsoleCommon {
    /**
     * Retrieves the title for the current console window.
     * @return title
     */
    public static String getTitle(){
        char[] buff = new char[1024*64];
        var charsCount = rawAPI().GetConsoleTitleW(buff,buff.length);
        if( charsCount==0 ){
            throwError("GetConsoleTitleW");
        }
        return charsCount<0 ? "" : new String(buff, 0, charsCount);
    }

    /**
     * Sets the title for the current console window.
     * @param title title
     */
    public static void setTitle(String title){
        if( title==null )throw new IllegalArgumentException("title==null");
        if( !rawAPI().SetConsoleTitleW(new WString(title)) ){
            throwError("SetConsoleTitleW");
        }
    }

    private static final int CONSOLE_TEXTMODE_BUFFER = 1;
    private static final WinDef.LPVOID nullRef = new WinDef.LPVOID();
    public static WinConsoleOutput createOutput(){
        var dwDesiredAccess = WinNT.GENERIC_READ | WinNT.GENERIC_WRITE;
        var dwShareMode = WinNT.FILE_SHARE_READ | WinNT.FILE_SHARE_WRITE;
        var handle = rawAPI().CreateConsoleScreenBuffer(
            dwDesiredAccess,
            dwShareMode,
            nullRef,
            CONSOLE_TEXTMODE_BUFFER,
            nullRef
        );
        if( WinConsoleRawAPI.INVALID_HANDLE_VALUE.equals(handle) ){
            throwError("CreateConsoleScreenBuffer("+dwDesiredAccess+","+dwShareMode+",nullRef,"+CONSOLE_TEXTMODE_BUFFER+",nullRef)");
        }
        return new WinConsoleOutput(handle,true);
    }

    public static void restoreControl(){
        if( !rawAPI().SetConsoleCtrlHandler(null,false) ){
            throwError("SetConsoleCtrlHandler(null,false)");
        }
    }

    /**
     * https://learn.microsoft.com/en-us/windows/console/setconsolectrlhandler
     *
     * <br>
     * Adds or removes an application-defined HandlerRoutine function from the list of handler functions for the calling process.
     *
     * <br>
     * If no handler function is specified, the function sets an inheritable attribute that determines whether the calling
     * process ignores CTRL+C signals.
     *
     * <br>
     * This function provides a similar notification for console application and services that WM_QUERYENDSESSION
     * provides for graphical applications with a message pump. You could also use this function from a graphical
     * application, but there is no guarantee it would arrive before the notification from WM_QUERYENDSESSION.
     *
     * <br>
     * Each console process has its own list of application-defined HandlerRoutine functions that handle CTRL+C
     * and CTRL+BREAK signals. The handler functions also handle signals generated by the system when the user closes
     * the console, logs off, or shuts down the system. Initially, the handler list for each process contains only a
     * default handler function that calls the ExitProcess function. A console process adds or removes additional handler
     * functions by calling the SetConsoleCtrlHandler function, which does not affect the list of handler functions for other processes.
     * When a console process receives any of the control signals, its handler functions are called on a last-registered,
     * first-called basis until one of the handlers returns TRUE. If none of the handlers returns TRUE, the default handler is called.
     *
     * <br>
     * Calling AttachConsole, AllocConsole, or FreeConsole will reset the table of control handlers in the client process to its initial state.
     * Handlers must be registered again when the attached console session changes.
     *
     * <br>
     * For console processes, the CTRL+C and CTRL+BREAK key combinations are typically treated as
     * signals (CTRL_C_EVENT and CTRL_BREAK_EVENT). When a console window with the keyboard focus receives CTRL+C
     * or CTRL+BREAK, the signal is typically passed to all processes sharing that console.
     *
     * <br>
     * CTRL+BREAK is always treated as a signal, but typical CTRL+C behavior can be changed in
     * three ways that prevent the handler functions from being called:
     *
     * <br>
     * The SetConsoleMode function can disable the ENABLE_PROCESSED_INPUT mode for a console's input buffer,
     * so CTRL+C is reported as keyboard input rather than as a signal.
     * Calling SetConsoleCtrlHandler with the NULL and TRUE arguments causes the calling process to ignore CTRL+C signals.
     * This attribute is inherited by child processes, but it can be enabled or disabled by any process
     * without affecting existing processes.
     * If a console process is being debugged and CTRL+C signals have not been disabled, the system generates a DBG_CONTROL_C exception.
     * This exception is raised only for the benefit of the debugger, and an application should never use an exception
     * handler to deal with it. If the debugger handles the exception, an application will not notice the CTRL+C, with
     * one exception: alertable waits will terminate. If the debugger passes the exception on unhandled, CTRL+C is
     * passed to the console process and treated as a signal, as previously discussed.
     * A console process can use the GenerateConsoleCtrlEvent function to send a CTRL+C or CTRL+BREAK signal to a console process group.
     *
     * <br>
     * The system generates CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT, and CTRL_SHUTDOWN_EVENT signals when the user closes
     * the console, logs off, or shuts down the system so that the process has an opportunity to clean up before
     * termination. Console functions, or any C run-time functions that call console functions, may not work
     * reliably during processing of any of the three signals mentioned previously. The reason is that some or all of
     * the internal console cleanup routines may have been called before executing the process signal handler.
     *
     * <br>
     * Windows 7, Windows 8, Windows 8.1 and Windows 10:
     *
     * <br>
     * If a console application loads the gdi32.dll or user32.dll library, the HandlerRoutine function that you specify
     * when you call SetConsoleCtrlHandler does not get called for the CTRL_LOGOFF_EVENT and CTRL_SHUTDOWN_EVENT events.
     * The operating system recognizes processes that load gdi32.dll or user32.dll as Windows applications rather than
     * console applications. This behavior also occurs for console applications that do not call functions in gdi32.dll
     * or user32.dll directly, but do call functions such as Shell functions that do in turn call
     * functions in gdi32.dll or user32.dll.
     *
     * <br>
     * To receive events when a user signs out or the device shuts down in these circumstances, create a hidden
     * window in your console application, and then handle the WM_QUERYENDSESSION and WM_ENDSESSION window messages
     * that the hidden window receives. You can create a hidden window by calling the CreateWindowEx method with
     * the dwExStyle parameter set to 0. An example of this is included with the basic handler example linked below.
     *
     * <hr>
     * <br>
     * Добавляет или удаляет определяемую приложением функцию HandlerRoutine из списка функций-обработчиков для вызывающего процесса.
     *
     * <br>
     * Если функция-обработчик не указана, функция устанавливает наследуемый атрибут, который определяет, будет ли
     * процесс игнорирует сигналы CTRL+C.
     *
     * <br>
     * Эта функция обеспечивает аналогичное уведомление для консольного приложения и служб, которые WM_QUERYENDSESSION
     * обеспечивает графические приложения с насосом сообщений. Вы также можете использовать эту функцию из графического
     * приложение, но нет гарантии, что оно прибудет до уведомления от WM_QUERYENDSESSION.
     *
     * <br>
     * Каждый консольный процесс имеет собственный список определяемых приложением функций HandlerRoutine, которые обрабатывают CTRL+C.
     * и сигналы CTRL+BREAK. Функции обработчика также обрабатывают сигналы, генерируемые системой, когда пользователь закрывает
     * консоль, выходит из системы или выключает систему. Изначально список обработчиков для каждого процесса содержит только
     * Функция обработчика по умолчанию, которая вызывает функцию ExitProcess. Консольный процесс добавляет или удаляет дополнительный обработчик
     * функции путем вызова функции SetConsoleCtrlHandler, которая не влияет на список функций-обработчиков для других процессов.
     * Когда консольный процесс получает любой из управляющих сигналов, его функции-обработчики вызываются на последнем зарегистрированном,
     * по первому вызову до тех пор, пока один из обработчиков не вернет TRUE. Если ни один из обработчиков не возвращает TRUE, вызывается обработчик по умолчанию.
     *
     * <br>
     * Вызов AttachConsole, AllocConsole или FreeConsole сбросит таблицу обработчиков элементов управления в клиентском процессе до исходного состояния.
     * Обработчики должны быть зарегистрированы снова при изменении подключенного сеанса консоли.
     *
     * <br>
     * Для консольных процессов комбинации клавиш CTRL+C и CTRL+BREAK обычно обрабатываются как
     * сигналы (CTRL_C_EVENT и CTRL_BREAK_EVENT). Когда окно консоли с фокусом клавиатуры получает CTRL+C
     * или CTRL+BREAK сигнал обычно передается всем процессам, совместно использующим эту консоль.
     *
     * <br>
     * CTRL+BREAK всегда воспринимается как сигнал, но обычное поведение CTRL+C можно изменить в
     * три способа предотвращения вызова функций-обработчиков:
     *
     * <br>
     * Функция SetConsoleMode может отключить режим ENABLE_PROCESSED_INPUT для входного буфера консоли,
     * поэтому CTRL+C воспринимается как ввод с клавиатуры, а не как сигнал.
     * Вызов SetConsoleCtrlHandler с аргументами NULL и TRUE приводит к тому, что вызывающий процесс игнорирует сигналы CTRL+C.
     * Этот атрибут наследуется дочерними процессами, но может быть включен или отключен любым процессом
     * не затрагивая существующие процессы.
     * Если консольный процесс отлаживается и сигналы CTRL+C не отключены, система создает исключение DBG_CONTROL_C.
     * Это исключение вызывается только в интересах отладчика, и приложение никогда не должно использовать исключение.
     * обработчик для работы с ним. Если отладчик обрабатывает исключение, приложение не заметит сочетание клавиш CTRL+C с
     * одно исключение: ожидание с оповещением прекращается. Если отладчик передает исключение в необработанном виде, CTRL+C
     * передается консольному процессу и обрабатывается как сигнал, как обсуждалось ранее.
     * Консольный процесс может использовать функцию GenerateConsoleCtrlEvent для отправки сигнала CTRL+C или CTRL+BREAK группе консольных процессов.
     *
     * <br>
     * Система генерирует сигналы CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT и CTRL_SHUTDOWN_EVENT, когда пользователь закрывает
     * консоль, выходит из системы или выключает систему, чтобы процесс имел возможность очиститься перед
     * прекращение. Консольные функции или любые функции времени выполнения C, которые вызывают консольные функции, могут не работать.
     * надежно при обработке любого из трех упомянутых ранее сигналов. Причина в том, что некоторые или все
     * внутренние подпрограммы очистки консоли могли быть вызваны до выполнения обработчика сигнала процесса.
     *
     * <br>
     * Windows 7, Windows 8, Windows 8.1 и Windows 10:
     *
     * <br>
     * Если консольное приложение загружает библиотеку gdi32.dll или user32.dll, указанная вами функция HandlerRoutine
     * при вызове SetConsoleCtrlHandler не вызывается для событий CTRL_LOGOFF_EVENT и CTRL_SHUTDOWN_EVENT.
     * Операционная система распознает процессы, загружающие gdi32.dll или user32.dll, как приложения Windows, а не
     * консольные приложения. Это также происходит для консольных приложений, которые не вызывают функции в gdi32.dll.
     * или user32.dll напрямую, но вызывают такие функции, как функции оболочки, которые, в свою очередь, вызывают
     * Функции в gdi32.dll или user32.dll.
     *
     * <br>
     * Чтобы получать события, когда пользователь выходит из системы или устройство выключается в этих обстоятельствах, создайте скрытый
     * окно в вашем консольном приложении, а затем обработайте WM_QUER
     * @param handler обрабочик
     * @return обрабочик
     */
    public static ControlHolder handleControl(ControlHandler handler){
        if( handler==null )throw new IllegalArgumentException("handler==null");
        ControlHolder holder = new ControlHolder(handler);
        if( !rawAPI().SetConsoleCtrlHandler(holder,true) ){
            throwError("SetConsoleCtrlHandler(holder,true)");
        }
        return holder;
    }
}
